<<<<<<< HEAD
/*
PhotoVault - Professional Photo Management Platform
Copyright (c) 2025 Calmic Sdn Bhd. All rights reserved.

Upload Interface Styles
*/

/* Upload Area Styling */
.upload-area {
    position: relative;
    border: 2px dashed #dee2e6;
    border-radius: 8px;
    padding: 2rem;
    text-align: center;
    background: linear-gradient(135deg, #fafbfc 0%, #f8f9fa 100%);
    transition: all 0.3s ease;
    cursor: pointer;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.upload-area:hover {
    border-color: var(--primary-color);
    background: linear-gradient(135deg, #e9ecef 0%, #f1f3f4 100%);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.upload-area.dragover {
    border-color: #007bff;
    background: linear-gradient(135deg, #e7f3ff 0%, #cce7ff 100%);
    transform: scale(1.02);
    box-shadow: 0 8px 25px rgba(0,123,255,0.2);
}

.upload-area input[type="file"] {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
    z-index: 2;
}

#uploadStatus {
    pointer-events: none;
    z-index: 1;
}

/* Camera Interface */
.camera-section {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 1rem;
}

.camera-preview {
    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
    border: 2px solid #dee2e6;
    border-radius: 8px;
    min-height: 250px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.camera-preview.camera-active {
    border-color: #28a745;
    background: #000;
}

.camera-preview video {
    max-width: 100%;
    max-height: 300px;
    border-radius: 6px;
    object-fit: cover;
}

.camera-placeholder {
    text-align: center;
    color: #6c757d;
    padding: 2rem;
}

.camera-placeholder i {
    opacity: 0.5;
}

/* Camera Controls */
.camera-controls {
    display: flex;
    gap: 1rem;
    align-items: end;
    flex-wrap: wrap;
}

.camera-controls .form-select {
    flex: 1;
    min-width: 200px;
}

.camera-controls .btn {
    white-space: nowrap;
}

/* Capture Overlay */
.capture-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    background: linear-gradient(transparent, rgba(0,0,0,0.7));
    padding: 1rem;
    display: none;
    z-index: 10;
}

.capture-overlay.active {
    display: block;
}

/* Capture Button */
#captureBtn {
    background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    border: none;
    border-radius: 50px;
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.5rem;
    transition: all 0.3s ease;
    margin: 0 auto;
    box-shadow: 0 4px 15px rgba(220, 53, 69, 0.3);
}

#captureBtn:hover {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(220, 53, 69, 0.4);
}

#captureBtn:active {
    transform: scale(0.95);
}

/* File Preview Items */
.file-preview-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
    padding: 1rem;
    background-color: #f8f9fa;
    border-radius: 6px;
}

.file-preview-item {
    position: relative;
    background: white;
    border-radius: 6px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    transition: transform 0.2s ease;
}

.file-preview-item:hover {
    transform: translateY(-2px);
}

.file-preview-item.camera-captured {
    border: 2px solid #28a745;
}

.file-preview-img {
    width: 100%;
    height: 80px;
    object-fit: cover;
}

.file-preview-name {
    padding: 0.5rem;
    font-size: 0.75rem;
    font-weight: 500;
    text-align: center;
    background-color: #f8f9fa;
}

.file-preview-size {
    padding: 0 0.5rem 0.5rem;
    font-size: 0.65rem;
    color: #6c757d;
    text-align: center;
}

.remove-file-btn {
    position: absolute;
    top: 4px;
    right: 4px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: none;
    background: rgba(220, 53, 69, 0.9);
    color: white;
    font-size: 0.75rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
}

.remove-file-btn:hover {
    background: #dc3545;
    transform: scale(1.1);
}

/* Progress Indicators */
.upload-progress {
    margin-top: 1rem;
    padding: 1rem;
    border-radius: 6px;
    background-color: #e7f3ff;
    border-left: 4px solid #007bff;
}

.progress-bar-custom {
    height: 8px;
    border-radius: 4px;
    background-color: #e9ecef;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #007bff, #0056b3);
    transition: width 0.3s ease;
}

/* Button States */
.btn-loading {
    position: relative;
    pointer-events: none;
}

.btn-loading::after {
    content: '';
    position: absolute;
    width: 16px;
    height: 16px;
    margin: auto;
    border: 2px solid transparent;
    border-top-color: currentColor;
    border-radius: 50%;
    animation: button-loading-spinner 1s ease infinite;
}

@keyframes button-loading-spinner {
    from { transform: rotate(0turn); }
    to { transform: rotate(1turn); }
}

/* Success States */
.upload-success {
    background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
    border-color: #28a745;
    color: #155724;
}

.upload-error {
    background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    border-color: #dc3545;
    color: #721c24;
}

/* Responsive Design */
@media (max-width: 768px) {
    .upload-area {
        padding: 1.5rem 1rem;
        min-height: 150px;
    }
    
    .camera-preview {
        min-height: 200px;
    }
    
    .camera-controls {
        flex-direction: column;
    }
    
    .camera-controls .form-select {
        min-width: unset;
    }
    
    .file-preview-container {
        grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
        gap: 0.5rem;
        padding: 0.5rem;
    }
    
    #captureBtn {
        width: 50px;
        height: 50px;
        font-size: 1.2rem;
    }
}

@media (max-width: 576px) {
    .upload-area {
        padding: 1rem 0.5rem;
    }
    
    .camera-preview {
        min-height: 180px;
    }
    
    .file-preview-container {
        grid-template-columns: repeat(3, 1fr);
    }
}

/* Accessibility */
.visually-hidden {
    position: absolute !important;
    width: 1px !important;
    height: 1px !important;
    padding: 0 !important;
    margin: -1px !important;
    overflow: hidden !important;
    clip: rect(0, 0, 0, 0) !important;
    white-space: nowrap !important;
    border: 0 !important;
}

/* Focus indicators */
.upload-area:focus-within {
    outline: 2px solid #007bff;
    outline-offset: 2px;
}

button:focus,
select:focus {
    outline: 2px solid #007bff;
    outline-offset: 2px;
}

/* Animation for file selection */
@keyframes file-select-success {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.upload-area.file-selected {
    animation: file-select-success 0.5s ease;
}

/* Camera error states */
.camera-error {
    background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
    border-color: #dc3545;
}

.camera-error .camera-placeholder {
    color: #721c24;
}
=======
/**
 * PhotoVault Upload Handler - NO CSRF VERSION
 * Camera support + file upload without CSRF token
 */

class PhotoVaultUploader {
    constructor() {
        // DOM Elements - File Upload
        this.fileInput = document.getElementById('fileInput');
        this.uploadArea = document.getElementById('uploadArea');
        this.selectPhotosBtn = document.getElementById('selectPhotosBtn');
        this.uploadForm = document.getElementById('uploadForm');
        this.selectedFilesArea = document.getElementById('selectedFilesArea');
        this.filePreviewContainer = document.getElementById('filePreviewContainer');
        this.uploadBtn = document.getElementById('uploadBtn');
        this.clearFilesBtn = document.getElementById('clearFilesBtn');
        this.uploadProgress = document.getElementById('uploadProgress');
        this.progressBar = document.getElementById('progressBar');
        this.progressText = document.getElementById('progressText');
        this.uploadMessages = document.getElementById('uploadMessages');
        this.fileCount = document.getElementById('fileCount');
        
        // DOM Elements - Camera
        this.cameraSelect = document.getElementById('cameraSelect');
        this.startCameraBtn = document.getElementById('startCameraBtn');
        this.stopCameraBtn = document.getElementById('stopCameraBtn');
        this.cameraPreviewArea = document.getElementById('cameraPreviewArea');
        this.cameraPlaceholder = document.getElementById('cameraPlaceholder');
        this.cameraVideo = document.getElementById('cameraVideo');
        this.captureOverlay = document.getElementById('captureOverlay');
        this.captureBtn = document.getElementById('captureBtn');
        this.captureCanvas = document.getElementById('captureCanvas');
        
        // State Management
        this.selectedFiles = [];
        this.capturedPhotos = [];
        this.isUploading = false;
        this.dialogState = 'closed';
        this.maxFileSize = 16 * 1024 * 1024; // 16MB
        this.allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];
        
        // Camera State
        this.availableCameras = [];
        this.currentStream = null;
        this.isCameraActive = false;
        this.captureCount = 0;
        
        // Initialize only once
        this.init();
    }
    
    init() {
        console.log('PhotoVault Uploader: Initializing with camera support (NO CSRF)...');
        
        // Remove any existing event listeners first
        this.removeAllEventListeners();
        
        // Bind events with prevention of multiple triggers
        this.bindEvents();
        
        // Initialize camera enumeration
        this.initializeCameraSupport();
        
        console.log('PhotoVault Uploader: Ready');
    }
    
    removeAllEventListeners() {
        // Clone elements to remove ALL event listeners
        if (this.selectPhotosBtn) {
            const newBtn = this.selectPhotosBtn.cloneNode(true);
            this.selectPhotosBtn.parentNode.replaceChild(newBtn, this.selectPhotosBtn);
            this.selectPhotosBtn = document.getElementById('selectPhotosBtn');
        }
    }
    
    bindEvents() {
        // PRIMARY: Button click to open file dialog
        this.selectPhotosBtn?.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.openFileDialog('button_click');
        });
        
        // SECONDARY: Upload area click (but not on button)
        this.uploadArea?.addEventListener('click', (e) => {
            if (!this.selectPhotosBtn?.contains(e.target)) {
                e.preventDefault();
                e.stopPropagation();
                this.openFileDialog('area_click');
            }
        });
        
        // File input change event
        this.fileInput?.addEventListener('change', (e) => {
            this.handleFileSelection(e);
        });
        
        // Drag and Drop
        this.setupDragAndDrop();
        
        // Form submission
        this.uploadForm?.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleUpload();
        });
        
        // Clear files button
        this.clearFilesBtn?.addEventListener('click', () => {
            this.clearSelection();
        });
        
        // Camera Events
        this.bindCameraEvents();
    }
    
    bindCameraEvents() {
        // Camera selection
        this.cameraSelect?.addEventListener('change', (e) => {
            this.selectedCameraId = e.target.value;
        });
        
        // Start camera
        this.startCameraBtn?.addEventListener('click', () => {
            this.startCamera();
        });
        
        // Stop camera
        this.stopCameraBtn?.addEventListener('click', () => {
            this.stopCamera();
        });
        
        // Capture photo
        this.captureBtn?.addEventListener('click', () => {
            this.capturePhoto();
        });
        
        // Tab switching
        document.getElementById('camera-tab')?.addEventListener('shown.bs.tab', () => {
            this.onCameraTabShown();
        });
        
        document.getElementById('file-tab')?.addEventListener('shown.bs.tab', () => {
            this.onFileTabShown();
        });
    }
    
    async initializeCameraSupport() {
        try {
            // Check if getUserMedia is supported
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.log('Camera not supported in this browser');
                this.disableCameraTab('Camera not supported in this browser');
                return;
            }
            
            // Enumerate cameras
            await this.enumerateCameras();
            
        } catch (error) {
            console.error('Error initializing camera support:', error);
            this.disableCameraTab('Camera initialization failed');
        }
    }
    
    async enumerateCameras() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            this.availableCameras = devices.filter(device => device.kind === 'videoinput');
            
            console.log(`Found ${this.availableCameras.length} cameras`);
            
            if (this.availableCameras.length === 0) {
                this.disableCameraTab('No cameras found');
                return;
            }
            
            // Populate camera select dropdown
            this.populateCameraSelect();
            
        } catch (error) {
            console.error('Error enumerating cameras:', error);
            this.disableCameraTab('Unable to access cameras');
        }
    }
    
    populateCameraSelect() {
        if (!this.cameraSelect) return;
        
        this.cameraSelect.innerHTML = '<option value="">Select Camera...</option>';
        
        this.availableCameras.forEach((camera, index) => {
            const option = document.createElement('option');
            option.value = camera.deviceId;
            option.textContent = camera.label || `Camera ${index + 1}`;
            this.cameraSelect.appendChild(option);
        });
        
        // Auto-select first camera
        if (this.availableCameras.length > 0) {
            this.cameraSelect.value = this.availableCameras[0].deviceId;
            this.selectedCameraId = this.availableCameras[0].deviceId;
        }
    }
    
    disableCameraTab(message) {
        const cameraTab = document.getElementById('camera-tab');
        if (cameraTab) {
            cameraTab.disabled = true;
            cameraTab.classList.add('disabled');
            cameraTab.title = message;
        }
    }
    
    async startCamera() {
        try {
            if (!this.selectedCameraId) {
                this.showMessage('Please select a camera first', 'warning');
                return;
            }
            
            // Stop existing stream
            await this.stopCamera();
            
            // Configure camera constraints
            const constraints = {
                video: {
                    deviceId: { exact: this.selectedCameraId },
                    width: { ideal: 1920, max: 1920 },
                    height: { ideal: 1080, max: 1080 },
                    facingMode: 'user' // Prefer front camera on mobile
                },
                audio: false
            };
            
            console.log('Starting camera with constraints:', constraints);
            
            // Get camera stream
            this.currentStream = await navigator.mediaDevices.getUserMedia(constraints);
            
            // Set up video element
            this.cameraVideo.srcObject = this.currentStream;
            this.cameraVideo.style.display = 'block';
            this.cameraPlaceholder.style.display = 'none';
            this.captureOverlay.style.display = 'block';
            
            // Update UI
            this.startCameraBtn.style.display = 'none';
            this.stopCameraBtn.style.display = 'inline-block';
            this.cameraPreviewArea.classList.add('camera-active');
            
            this.isCameraActive = true;
            this.showMessage('Camera started successfully!', 'success');
            
        } catch (error) {
            console.error('Error starting camera:', error);
            this.handleCameraError(error);
        }
    }
    
    async stopCamera() {
        try {
            if (this.currentStream) {
                this.currentStream.getTracks().forEach(track => {
                    track.stop();
                });
                this.currentStream = null;
            }
            
            // Reset UI
            this.cameraVideo.style.display = 'none';
            this.cameraPlaceholder.style.display = 'flex';
            this.captureOverlay.style.display = 'none';
            this.startCameraBtn.style.display = 'inline-block';
            this.stopCameraBtn.style.display = 'none';
            this.cameraPreviewArea.classList.remove('camera-active');
            
            this.isCameraActive = false;
            console.log('Camera stopped');
            
        } catch (error) {
            console.error('Error stopping camera:', error);
        }
    }
    
    handleCameraError(error) {
        let message = 'Camera access failed';
        
        if (error.name === 'NotAllowedError') {
            message = 'Camera permission denied. Please allow camera access and try again.';
        } else if (error.name === 'NotFoundError') {
            message = 'Camera not found. Please check your camera connection.';
        } else if (error.name === 'NotReadableError') {
            message = 'Camera is already in use by another application.';
        } else if (error.name === 'OverconstrainedError') {
            message = 'Camera constraints not supported. Trying with default settings...';
            // Retry with basic constraints
            this.retryWithBasicConstraints();
            return;
        }
        
        this.showMessage(message, 'error');
        this.cameraPreviewArea.classList.add('camera-error');
        
        // Show permission denied UI if needed
        if (error.name === 'NotAllowedError') {
            this.showCameraPermissionDenied();
        }
    }
    
    async retryWithBasicConstraints() {
        try {
            const basicConstraints = {
                video: { deviceId: { exact: this.selectedCameraId } },
                audio: false
            };
            
            this.currentStream = await navigator.mediaDevices.getUserMedia(basicConstraints);
            this.cameraVideo.srcObject = this.currentStream;
            this.cameraVideo.style.display = 'block';
            this.cameraPlaceholder.style.display = 'none';
            this.captureOverlay.style.display = 'block';
            
            this.isCameraActive = true;
            this.showMessage('Camera started with basic settings', 'success');
            
        } catch (retryError) {
            console.error('Retry with basic constraints failed:', retryError);
            this.handleCameraError(retryError);
        }
    }
    
    showCameraPermissionDenied() {
        this.cameraPlaceholder.innerHTML = `
            <div class="camera-permission-denied">
                <i class="fas fa-camera-slash"></i>
                <h5>Camera Permission Required</h5>
                <p>Please allow camera access in your browser settings and refresh the page.</p>
                <small class="text-muted">
                    Look for the camera icon in your browser's address bar
                </small>
            </div>
        `;
    }
    
    capturePhoto() {
        if (!this.isCameraActive || !this.currentStream) {
            this.showMessage('Camera is not active', 'error');
            return;
        }
        
        try {
            // Set up canvas
            const canvas = this.captureCanvas;
            const context = canvas.getContext('2d');
            const video = this.cameraVideo;
            
            // Set canvas dimensions to video dimensions
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            // Draw current video frame to canvas
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Convert canvas to blob
            canvas.toBlob((blob) => {
                if (blob) {
                    this.processCapturedPhoto(blob);
                } else {
                    this.showMessage('Failed to capture photo', 'error');
                }
            }, 'image/jpeg', 0.9);
            
        } catch (error) {
            console.error('Error capturing photo:', error);
            this.showMessage('Failed to capture photo', 'error');
        }
    }
    
    processCapturedPhoto(blob) {
        // Create a file object from the blob
        this.captureCount++;
        const fileName = `camera-capture-${Date.now()}-${this.captureCount}.jpg`;
        const file = new File([blob], fileName, { type: 'image/jpeg' });
        
        console.log(`Photo captured: ${fileName}, size: ${this.formatFileSize(file.size)}`);
        
        // Add to captured photos array
        this.capturedPhotos.push(file);
        
        // Add to selected files for upload
        this.selectedFiles.push(file);
        
        // Update UI
        this.displayFilePreview();
        this.updateFileCount();
        this.selectedFilesArea.style.display = 'block';
        
        this.showMessage(`Photo captured! ${fileName}`, 'success');
        
        // Brief visual feedback
        this.captureBtn.style.transform = 'scale(0.9)';
        setTimeout(() => {
            this.captureBtn.style.transform = '';
        }, 150);
    }
    
    onCameraTabShown() {
        // Refresh camera enumeration when tab is shown
        this.enumerateCameras();
    }
    
    onFileTabShown() {
        // Stop camera when switching to file tab
        if (this.isCameraActive) {
            this.stopCamera();
        }
    }
    
    // ===== FILE UPLOAD METHODS =====
    
    openFileDialog(source) {
        // CRITICAL: Prevent multiple dialogs
        if (this.dialogState === 'opening' || this.dialogState === 'open') {
            console.log(`PhotoVault: Dialog already ${this.dialogState}, ignoring ${source}`);
            return;
        }
        
        if (this.isUploading) {
            console.log('PhotoVault: Upload in progress, ignoring dialog request');
            return;
        }
        
        console.log(`PhotoVault: Opening file dialog from ${source}`);
        
        // Set state to prevent multiple opens
        this.dialogState = 'opening';
        this.fileInput.dataset.dialogState = 'opening';
        
        // Reset state after dialog interaction
        const resetDialogState = () => {
            setTimeout(() => {
                this.dialogState = 'closed';
                this.fileInput.dataset.dialogState = 'closed';
            }, 500);
        };
        
        // Listen for focus return (dialog closed)
        const focusHandler = () => {
            resetDialogState();
            window.removeEventListener('focus', focusHandler);
        };
        window.addEventListener('focus', focusHandler);
        
        // Also reset after a timeout as backup
        setTimeout(resetDialogState, 2000);
        
        // Trigger file input
        this.fileInput.click();
        this.dialogState = 'open';
    }
    
    handleFileSelection(e) {
        const files = Array.from(e.target.files || []);
        console.log(`PhotoVault: ${files.length} files selected`);
        
        if (files.length === 0) {
            return;
        }
        
        // Validate files
        const validFiles = this.validateFiles(files);
        
        if (validFiles.length === 0) {
            this.showMessage('No valid image files selected', 'warning');
            return;
        }
        
        // Add to selected files (preserve existing captured photos)
        this.selectedFiles = [...this.selectedFiles, ...validFiles];
        
        // Update UI
        this.displayFilePreview();
        this.updateFileCount();
        this.selectedFilesArea.style.display = 'block';
        
        this.showMessage(`${validFiles.length} files added for upload`, 'success');
    }
    
    validateFiles(files) {
        const validFiles = [];
        const errors = [];
        
        files.forEach(file => {
            // Check file type
            if (!this.allowedTypes.includes(file.type)) {
                errors.push(`${file.name}: Invalid file type`);
                return;
            }
            
            // Check file size
            if (file.size > this.maxFileSize) {
                errors.push(`${file.name}: File too large (max 16MB)`);
                return;
            }
            
            validFiles.push(file);
        });
        
        // Show validation errors
        if (errors.length > 0) {
            this.showMessage(`Some files were rejected:<br>${errors.join('<br>')}`, 'warning');
        }
        
        return validFiles;
    }
    
    displayFilePreview() {
        this.filePreviewContainer.innerHTML = '';
        
        this.selectedFiles.forEach((file, index) => {
            const previewItem = document.createElement('div');
            previewItem.className = 'file-preview-item';
            
            // Mark camera-captured photos
            if (this.capturedPhotos.includes(file)) {
                previewItem.classList.add('camera-captured');
            }
            
            // Create image preview
            const img = document.createElement('img');
            img.className = 'file-preview-img';
            img.alt = file.name;
            
            // Create file reader for preview
            const reader = new FileReader();
            reader.onload = (e) => {
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
            
            // File info
            const fileName = document.createElement('div');
            fileName.className = 'file-preview-name';
            fileName.textContent = file.name.length > 20 ? 
                file.name.substring(0, 17) + '...' : file.name;
            
            const fileSize = document.createElement('div');
            fileSize.className = 'file-preview-size';
            fileSize.textContent = this.formatFileSize(file.size);
            
            // Remove button
            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-file-btn';
            removeBtn.innerHTML = '×';
            removeBtn.title = 'Remove file';
            removeBtn.onclick = (e) => {
                e.stopPropagation();
                this.removeFile(index);
            };
            
            // Assemble preview item
            previewItem.appendChild(img);
            previewItem.appendChild(fileName);
            previewItem.appendChild(fileSize);
            previewItem.appendChild(removeBtn);
            
            this.filePreviewContainer.appendChild(previewItem);
        });
    }
    
    removeFile(index) {
        const removedFile = this.selectedFiles[index];
        
        // Remove from captured photos array if it was captured
        if (this.capturedPhotos.includes(removedFile)) {
            const capturedIndex = this.capturedPhotos.indexOf(removedFile);
            this.capturedPhotos.splice(capturedIndex, 1);
        }
        
        // Remove from selected files
        this.selectedFiles.splice(index, 1);
        
        if (this.selectedFiles.length === 0) {
            this.clearSelection();
        } else {
            this.displayFilePreview();
            this.updateFileCount();
        }
    }
    
    clearSelection() {
        this.selectedFiles = [];
        this.capturedPhotos = [];
        this.fileInput.value = '';
        this.selectedFilesArea.style.display = 'none';
        this.filePreviewContainer.innerHTML = '';
        this.hideProgress();
        this.dialogState = 'closed';
        this.captureCount = 0;
    }
    
    updateFileCount() {
        if (this.fileCount) {
            this.fileCount.textContent = this.selectedFiles.length;
        }
    }
    
    setupDragAndDrop() {
        if (!this.uploadArea) return;
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            this.uploadArea.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
        });
        
        ['dragenter', 'dragover'].forEach(eventName => {
            this.uploadArea.addEventListener(eventName, () => {
                this.uploadArea.classList.add('dragover');
            });
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            this.uploadArea.addEventListener(eventName, () => {
                this.uploadArea.classList.remove('dragover');
            });
        });
        
        this.uploadArea.addEventListener('drop', (e) => {
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                // Validate and add files
                const validFiles = this.validateFiles(files);
                
                if (validFiles.length > 0) {
                    // Add to existing selection
                    this.selectedFiles = [...this.selectedFiles, ...validFiles];
                    this.displayFilePreview();
                    this.updateFileCount();
                    this.selectedFilesArea.style.display = 'block';
                    this.showMessage(`${validFiles.length} files added via drag and drop`, 'success');
                }
            }
        });
    }
    
    async handleUpload() {
        if (this.selectedFiles.length === 0) {
            this.showMessage('Please select files or capture photos to upload', 'warning');
            return;
        }
        
        if (this.isUploading) {
            console.log('Upload already in progress');
            return;
        }
        
        // Stop camera if active during upload
        if (this.isCameraActive) {
            await this.stopCamera();
        }
        
        this.isUploading = true;
        this.showProgress();
        this.uploadBtn.classList.add('loading');
        this.uploadBtn.disabled = true;
        
        try {
            // Create FormData
            const formData = new FormData();
            
            // NO CSRF TOKEN - REMOVED FOR TESTING
            console.log('📤 Uploading without CSRF token');
            
            // Add files (both uploaded and captured)
            this.selectedFiles.forEach(file => {
                formData.append('photos', file);
            });
            
            // Upload with progress
            const response = await this.uploadWithProgress(formData);
            
            if (response.ok) {
                const result = await response.json();
                const totalUploaded = result.uploaded || this.selectedFiles.length;
                const capturedCount = this.capturedPhotos.length;
                
                let message = `Successfully uploaded ${totalUploaded} photos!`;
                if (capturedCount > 0) {
                    message += ` (${capturedCount} captured from camera)`;
                }
                
                this.showMessage(message, 'success');
                this.clearSelection();
                
                // Refresh page to show new uploads
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
            } else {
                throw new Error(`Upload failed: ${response.status}`);
            }
            
        } catch (error) {
            console.error('Upload error:', error);
            this.showMessage(`Upload failed: ${error.message}`, 'error');
        } finally {
            this.isUploading = false;
            this.hideProgress();
            this.uploadBtn.classList.remove('loading');
            this.uploadBtn.disabled = false;
        }
    }
    
    uploadWithProgress(formData) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            
            // Progress handler
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const percentComplete = (e.loaded / e.total) * 100;
                    this.updateProgress(percentComplete, `Uploading ${Math.round(percentComplete)}%`);
                }
            });
            
            // Load handler
            xhr.addEventListener('load', () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve({
                        ok: true,
                        status: xhr.status,
                        json: () => Promise.resolve(JSON.parse(xhr.responseText || '{}'))
                    });
                } else {
                    reject(new Error(`HTTP ${xhr.status}: ${xhr.statusText}`));
                }
            });
            
            // Error handler
            xhr.addEventListener('error', () => {
                reject(new Error('Network error'));
            });
            
            // Open and send
            xhr.open('POST', this.uploadForm.action || '/photos/upload');
            xhr.send(formData);
        });
    }
    
    showProgress() {
        if (this.uploadProgress) {
            this.uploadProgress.style.display = 'block';
            this.updateProgress(0, 'Preparing upload...');
        }
    }
    
    hideProgress() {
        if (this.uploadProgress) {
            this.uploadProgress.style.display = 'none';
        }
    }
    
    updateProgress(percent, text) {
        if (this.progressBar) {
            this.progressBar.style.width = `${percent}%`;
        }
        if (this.progressText) {
            this.progressText.textContent = text;
        }
    }
    
    showMessage(message, type = 'info') {
        if (!this.uploadMessages) return;
        
        const alertClass = {
            'success': 'alert-success',
            'error': 'alert-danger',
            'warning': 'alert-warning',
            'info': 'alert-info'
        }[type] || 'alert-info';
        
        this.uploadMessages.innerHTML = `
            <div class="alert ${alertClass} alert-dismissible fade show" role="alert">
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            </div>
        `;
        
        // Auto-hide success messages
        if (type === 'success') {
            setTimeout(() => {
                const alert = this.uploadMessages.querySelector('.alert');
                if (alert) {
                    alert.classList.remove('show');
                }
            }, 5000);
        }
    }
    
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    // Cleanup method
    destroy() {
        if (this.currentStream) {
            this.stopCamera();
        }
    }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    console.log('PhotoVault: DOM loaded, initializing uploader (NO CSRF VERSION)...');
    
    // Ensure only one instance
    if (window.photoVaultUploader) {
        console.log('PhotoVault: Uploader already exists, skipping initialization');
        return;
    }
    
    window.photoVaultUploader = new PhotoVaultUploader();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (window.photoVaultUploader) {
        window.photoVaultUploader.destroy();
    }
});

// Prevent multiple initializations
window.addEventListener('load', () => {
    if (!window.photoVaultUploader) {
        console.log('PhotoVault: Fallback initialization');
        window.photoVaultUploader = new PhotoVaultUploader();
    }
});
>>>>>>> d7a78a54c0ad65f18ff94f6c70f442201aeb0f38
